Pouria Shirasb
Assignment #3
Report

-------------------------------------------------------------------------------
 Part A
-------------------------------------------------------------------------------
I have implemented all the required functionality for part A. I started off by
implementing scene signature. Since we only had two objects, I used each
object's diffuse color as its signature. Then I comepleted the shading functions
and saved the required images as instructed. Although, as I was debugging the
program, I changed the position of the light in the Y direction and forgot to
put it back, so in my images the light is a bit higher than it was originally.
raytracer.cpp.backup is main file I used to generate the images. However, since
I changed other header files and what not for part B, it won't compile anymore
but I left it there anyway as a reference.

-------------------------------------------------------------------------------
 Part B
-------------------------------------------------------------------------------

For this part, I extended the raytracer to have the following features:

I.   Anti-aliasing
II.  Soft Shadows
III. Glossy-Reflections
IV.  Refractions
V.   Depth of field
VI.  Parallel Processing

The relevant control flow of my program is as follows:

- render()
    - render_thread() // runs this _max_threads times in parallel
        - shadeRay() 
            - computeShading()
                - traceShadow()
                    - shade()
                - traceRefraction()
                    - traceReflection()
                        - shadeRay
                            - ... (recursion) ...
                - shadeAmbient()
            



-------------------------------------------------------------------------------
I. Anti-aliasing

Anti-aliasing is done in Raytracer::render_thread() by casting multiple rays per
pixel and averaging the results. The number of samples is defined in raytracer.h
as _aa_samples, which results in (_aa_samples^2) rays per pixel. The points are
chosen deterministically. This feature was extremely computationally expensive
and therefore I could not experiment much with it. For most of the images, I 
used either 2x2 or 3x3 anti-aliasing. 

II. Soft Shadows

In order to produce soft shadows, I added a new class called AreaLight to 
light_source.h/cpp. AreaLight is similar to point light except that in
addition to position, it has two vectors u,v which determine the "sides"
of the area light. Soft shadows are generated by casting (_shadow_samples^2)
rays from an intersection point to the area light and checking whether they 
intersect an object or not, and the results are averaged and added to ray color.
This is implemented in Raytracer::traceShadow() which is called from 
computeShading(). I should also note the sampling for soft shadows is jittered
since it resulted in less grainy yet smoother images.

III. Glossy Reflections

Reflection is done in Raytracer::traceReflection() which given a ray and 
a current depth, calculates the perfect reflection anglei. If material is glossy
then casts (_gloss_samples^2) rays in that direction and calls traceReflection 
on those rays recursively til _max_depth is reached and eventually averages the
results. It is called from Raytracer::traceRefraction.
Note that both reflection and refraction only work for dielectric
materials for which I added a new property called "type" to Material struct 
that determines whether a material is dielectric or diffuse.

IV. Refraction

For refraction, I closely followed the book's implementation on pages 306
and 307. Raytracer::traceRefraction(), which again only works on dielectrics,
uses Schlick's approximation to Fresnel equations to determine how much is
going to be reflected and how much refracted. It also includes Beer's law
to model intensity loss. 


V. Depth of field

Depth of field is implemented inside anti-aliasing loop in render_thread().
It finds the point on the focal plane, although it is not a plane per say,
it is more of an arc around the eye with radius of focal distance. Then,
samples a point around the eye and casts (_dof_samples^2) rays from the new 
point to the focal point and averages the results. Like anti-aliasing, this
feature was computationally expensive which made it hard to play around with. 

VI. Parallel Processing

In addition to the features above, I added concurrency support early on to
improve the rendering times. It simply forks() into _max_threads processes
each of which then calls render_thread() and handles 1/_max_threads rows of
pixels concurrently. This significantly improved the rendering times for me.


-------------------------------------------------------------------------------
 Additional Notes
-------------------------------------------------------------------------------
I have included sample images that I rendered along the way in the folder.
For most, the name of the image is descriptive of what features were used.

For example: 
2aa_7gloss_3shadow_1.bmp: 2x2 anti-aliasing, 7x7 gloss samples, 
                          3x3 shadow samples, view 1
7dof_3shadow.bmp: 7x7 depth-of-field samples, 3x3 shadow samples





